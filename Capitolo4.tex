\chapter{Assegnamento degli autovalori con feedback di stato}



\section{Caso MIMO}
Consideriamo un sistema LTI descritto dalle equazioni di stato:
\[
\dot{x}(t) = Ax(t) + Bu(t)
\]
con \(A \in \mathbb{R}^{n \times n}\), 
\(B \in \mathbb{R}^{n \times m}\), 
\(x \in \mathbb{R}^n\) e \(u \in \mathbb{R}^m\). 
Il nostro obiettivo  è attraverso un feedback di stato del tipo:
\begin{equation}
    u(t) = Kx(t)
\end{equation}
con \(K \in \mathbb{R}^{m \times n}\)
(dunque \(Kx \in \mathbb{R}^{ m\times 1}\)) riuscire ad 
assegnare gli autovalori del sistema con matrice della dinamica:
\begin{equation}
    A+BK
\end{equation}
indicheremo l'insieme degli autovalori 
di una matrice \(A\) con \(\sigma(A)\),
dunque noi vogliamo scegliere \(K\) in modo tale da 
poter assegnare l'insieme \(\sigma(A+BK)\) a piacere:
\[\sigma(A+BK) = 
\left\{\lambda_1, \lambda_2, \ldots, \lambda_n
\right\}\]
Per i sistemi MIMO esistono infinite soluzioni al problema di assegnamento 
degli autovalori, cioè esistono infinite matrici \(K\)
tali che l'insieme degli autovalori di \(A+BK\) sia uguale
all'insieme desiderato. Noi andremo a vedere delle soluzioni operative che 
ci permettono di trovare alcune di queste infinite matrici \(K\) soluzioni del problema,
nello specifico vedremo i seguenti 3 metodi:
\begin{itemize}
    \item Metodo della forma canonica di controllabilità
    \item Metodo dell'equazione di Sylvester
    \item Metodo di Kautsky-Nichols-Van Dooren
\end{itemize}

\section{Metodo della forma canonica di controllabilità}
Per sistemi MIMO se la coppia \((A,B)\) è 
completamente controllabile allora è possibile trovare 
una matrice di trasformazione \(T\) che porta il sistema
in una forma canonica di controllabilità a blocchi,
detta forma di Brunovsky:
\[
z = T^{-1}x \Longleftrightarrow x = Tz 
\]

Con le matrici del sistema nella nuova base che valgono:
\begin{equation}
    A_{c} = T^{-1}AT  =
    \begin{pmatrix}
        A_{c1} & 0 & \cdots & 0 \\
        0 & A_{c2} & \cdots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        0 & 0 & \cdots & A_{cm}
    \end{pmatrix}
    , \quad B_{c} = T^{-1}B
    = \begin{pmatrix}
        B_{c1} & 0 & \cdots & 0 \\
        0 & B_{c2} & \cdots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        0 & 0 & \cdots & B_{cm}
\end{pmatrix}
\end{equation}
Con \(A_{ci} \in \mathbb{R}^{n_{i} \times n_{i}}\)
e \(B_{ci} \in \mathbb{R}^{n_{i} \times 1}\) che valgono:
\[
A_{ci} =
\begin{pmatrix}
    0 & 1 & 0 & \cdots & 0 \\
    0 & 0 & 1 & \cdots & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    -a_{i1} & -a_{i2} & -a_{i3} & \cdots & -a_{in_i} \\
\end{pmatrix}
, \quad
B_{ci} =
\begin{pmatrix}
    0 \\
    0 \\
    \vdots \\
    0 \\
    1
\end{pmatrix}
\]
Inoltre si ha che \(n_{1} + n_{2} + \dots + n_{m} = n\). 
Notiamo che ogni coppia \((A_{ci}, B_{ci})\) rappresenta una 
forma canonica di controllabilità rispetto all'ingresso \(u_{i}\).
Notiamo 
che per come è scritta la matrice \(A_{c}\) con una retroazione 
di stato del tipo:
\[u = K_{c}z\]
con \(K_{c} \in \mathbb{R}^{m \times n}\):
\[
K_{c} =
\begin{pmatrix}
    k_{c1} & 0 & \cdots & 0 \\
    0 & k_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & k_{cm}
\end{pmatrix}
\]
con \(k_{ci} \in \mathbb{R}^{1 \times n_{i}}\).
Con \(K_{c}\) scritto in questo modo 
si ha che la matrice della dinamica del sistema 
in retroazione di stato è:
\[
A_{c} + B_{c}K_{c} =
\begin{pmatrix}
    A_{c1} & 0 & \cdots & 0 \\
    0 & A_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & A_{cm}
\end{pmatrix}
+
 \begin{pmatrix}
        B_{c1} & 0 & \cdots & 0 \\
        0 & B_{c2} & \cdots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        0 & 0 & \cdots & B_{cm}
\end{pmatrix}
\begin{pmatrix}
    k_{c1} & 0 & \cdots & 0 \\
    0 & k_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & k_{cm}
\end{pmatrix}
\]
Notando che \(B_{ci} k_{ci} \in \mathbb{R}^{n_{i} \times n_{i}}\)
si ha che:
\[
A_{c} + B_{c}K_{c} =
\begin{pmatrix}
    A_{c1} + B_{c1}k_{c1} & 0 & \cdots & 0 \\
    0 & A_{c2} + B_{c2}k_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & A_{cm} + B_{cm}k_{cm}
\end{pmatrix}
\]
Ma la matrice \(A_{c} + B_{c} + K_{c}\)
è diagonale a blocchi dunque si ha che
gli autovalori della matrice sono gli autovalori
dei blocchi diagonali:
\[
\sigma(A_{c} + B_{c}K_{c}) =
\bigcup_{i=1}^{m}
\sigma(A_{ci} + B_{ci}k_{ci})
\]
Ma ogni singolo blocco diagonale 
\(A_{ci} + B_{ci}k_{ci}\) rappresenta un sistema SISO
in forma canonica di controllabilità, e la coppia \((A_{ci}, B_{ci})\)
è completamente controllabile per ipotesi (essendo 
controllabile il sistema originale \((A,B)\)),
dunque per il teorema di assegnamento degli autovalori
applicato ai sistemi SISO esiste \(k_{ci}\)
tale che possiamo assegnare gli autovalori
di ogni blocco diagonale \(A_{ci} + B_{ci}k_{ci}\).
Questo \(k_{ci}\) si trova imponendo
che il polinomio caratteristico del blocco
\(A_{ci} + B_{ci}k_{ci}\)
sia uguale al polinomio caratteristico
desiderato:
\[\det(sI - (A_{ci} + B_{ci}k_{ci})) =
    s^{n_{i}} + \alpha_{i1}s^{n_{i}-1} +
     \alpha_{i2}s^{n_{i}-2} + \ldots + \alpha_{in_{i}}
\]
Ovviamente questo va fatto \(\forall i=1, \dots , m\).
Una volta trovati tutti i \(k_{ci}\)
possiamo costruire la matrice \(K_{c}\), 
per riportarla nella base originale del sistema
basta ricordare:
\[u=K_{c} z= K_{c} T^{-1}x \Longrightarrow 
K= K_{c}T^{-1}\]


\section{Metodo dell'equazione di Sylvester}
Un altro metodo per l'assegnamento degli autovalori 
per sistemi MIMO è il metodo dell'equazione di Sylvester.
L'equazione di Sylvester è la seguente equazione matriciale:
\begin{equation}
    AX + XB = C
\end{equation}
in cui \(A \in \mathbb{R}^{n \times n}\),
\(B \in \mathbb{R}^{m \times m}\) e \(C \in \mathbb{R}^{n \times m}\)
sono matrici note, mentre \(X \in \mathbb{R}^{n \times m}\)
è la matrice incognita da trovare. Andiamo ad analizzare 
questa equazione:
\begin{itemize}
    \item \textbf{Unicità della soluzione}: L'equazione di Sylvester ammettete
    una soluzione unica se e solo se gli insiemi degli spettri di \(A\) e \(-B\)
    sono disgiunti, cioè hanno intersezione uguale all'insieme vuoto:
    \[\sigma(A) \cap \sigma(-B) = \emptyset \Longleftrightarrow 
    \lambda_{i}(A) + \lambda_{j}(B) \neq 0 \quad \forall i,j\]
    in parole povere le matrici \(A\) e \(B\) non devono avere autovalori
    con segni opposti, cioè \(A\) e \(-B\) non devono avere autovalori in comune.
    Ad esempio se \(A\) ha un autovalore \(\lambda_{A} = 2\) e \(B\) ha un autovalore 
    \(\lambda_{B} = -2\) allora l'equazione di Sylvester non ammette una soluzione unica.
    \item \textbf{Esistenza della soluzione}: L'equazione di Sylvester ammette almeno
    una soluzione se e solo se:
    \[vec(C) \in Im \left(I_{m} \otimes A + B^{T} \otimes I_{n}\right)\]
    cioè se la matrice \(C\) appartiene all'immagine dell'operatore \(L(X)\):
    \[L(X) = AX + XB\]
    cioè esiste un \(X\) tale che \(L(X) = C\).
\end{itemize}

Ora torniamo al nostro problema di assegnamento degli autovalori
per sistemi MIMO. Ricordiamo che il nostro obiettivo è trovare 
la matrice \(K\) tale che:
\[\sigma(A + BK) =
\left\{\lambda_{1}, \lambda_{2}, \ldots, \lambda_{n}\right\}\]
Ma se esiste questa \(K\) allora costruita una matrice \(T\)
che ha sulle colonne gli autovettori associati agli autovalori
desiderati si ha che per 
la definizione di autovettore e autovalore (poichè
il prodotto \((A+BK)T\) equivale a moltiplicare la matrice
\(A+BK\) per ogni autovettore sulle colonne di \(T\)):
\[(A + BK)T = T \Lambda \]
con \(\Lambda\) matrice diagonale(o a blocchi) con gli autovalori desiderati sulla diagonale.

\section{Diagonalizzare}

Sia dato un sistema LTI descritto dalle equazioni di stato:
\[
\dot{x}(t) = Ax(t) + Bu(t)
\]
quando noi diamo un sistema in questa forma diamo per assodato che il vettore 
\(x\) sia scritto nella base canonica di \(\mathbb{R}^{n}\).
Se la matrice \(A\) è diagonalizzabile, ci poniamo il problema di portare \(x\)
in un nuovo stato \(\hat{x}\) in cui \(A\) è diagonale. 
Dunque cerchiamo una matrice di trasformazione \(T\) tale che:
\[ x = T \hat{x} \Longrightarrow
\hat{A} = T^{-1} A T \textnormal{ è diagonale}\] 
Ma come si può immediatamente notare la matrice \(T\) è la matrice del cambiamento 
di base dalla base canonica alla base che diagonalizza \(A\).
Quindi a noi basta trovare la matrice che permette di portare il vettore \(\hat{x}\),
scritto nella base che diagonalizza \(A\), 
nel vettore \(x\) scritto nella base canonica.
Ma la base che diagonalizza \(A\) è formata dagli autovettori di \(A\),
dunque scegliamo un insieme di autovettori linearmente indipendenti di \(A\):
\[ \hat{B} = \left\{v_{1}, v_{2}, \ldots, v_{n}\right\} \] 
Per calcolare \(T\) dobbiamo ricordare che la matrice del cambiamento di base
si calcola attraverso l'applicazione identità (che è un applicazione lineare),
dunque applichiamo l'identità agli autovettori scelti:
\[ Id(\hat{B}) =\left\{v_{1} , v_{2} , \ldots , v_{n}\right\} \]
Ora scomponiamo i vettori rispetto alla base canonica 
ed incolonniamoli come colonne della matrice \(T\)(
la base canonica è molto comoda perchè ci permette di scrivere i vettori
proprio come sono), dunque la matrice \(T\) vale:
\[ T = \begin{pmatrix}
    v_{1} & v_{2} & \ldots & v_{n}
\end{pmatrix}\]
In cui i vettori \(v_{1}, v_{2}, \ldots , v_{n} \in \mathbb{R}^{n \times 1}\)
sono vettori colonna \(n \times 1\), dunque la matrice \(T \in \mathbb{R}^{n \times n}\).