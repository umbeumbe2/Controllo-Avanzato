\chapter{Assegnamento degli autovalori con feedback di stato}



\section{Caso MIMO}
Consideriamo un sistema LTI descritto dalle equazioni di stato:
\[
\dot{x}(t) = Ax(t) + Bu(t)
\]
con \(A \in \mathbb{R}^{n \times n}\), 
\(B \in \mathbb{R}^{n \times m}\), 
\(x \in \mathbb{R}^n\) e \(u \in \mathbb{R}^m\). 
Il nostro obiettivo  è attraverso un feedback di stato del tipo:
\begin{equation}
    u(t) = Kx(t)
\end{equation}
con \(K \in \mathbb{R}^{m \times n}\)
(dunque \(Kx \in \mathbb{R}^{ m\times 1}\)) riuscire ad 
assegnare gli autovalori del sistema con matrice della dinamica:
\begin{equation}
    A+BK
\end{equation}
indicheremo l'insieme degli autovalori 
di una matrice \(A\) con \(\sigma(A)\),
dunque noi vogliamo scegliere \(K\) in modo tale da 
poter assegnare l'insieme \(\sigma(A+BK)\) a piacere:
\[\sigma(A+BK) = 
\left\{\lambda_1, \lambda_2, \ldots, \lambda_n
\right\}\]
Per i sistemi MIMO esistono infinite soluzioni al problema di assegnamento 
degli autovalori, cioè esistono infinite matrici \(K\)
tali che l'insieme degli autovalori di \(A+BK\) sia uguale
all'insieme desiderato. Noi andremo a vedere delle soluzioni operative che 
ci permettono di trovare alcune di queste infinite matrici \(K\) soluzioni del problema,
nello specifico vedremo i seguenti 3 metodi:
\begin{itemize}
    \item Metodo della forma canonica di controllabilità
    \item Metodo dell'equazione di Sylvester
    \item Metodo di Kautsky-Nichols-Van Dooren
\end{itemize}

\section{Metodo della forma canonica di controllabilità}
Per sistemi MIMO se la coppia \((A,B)\) è 
completamente controllabile allora è possibile trovare 
una matrice di trasformazione \(T\) che porta il sistema
in una forma canonica di controllabilità a blocchi,
detta forma di Brunovsky:
\[
z = T^{-1}x \Longleftrightarrow x = Tz 
\]

Con le matrici del sistema nella nuova base che valgono:
\begin{equation}
    A_{c} = T^{-1}AT  =
    \begin{pmatrix}
        A_{c1} & 0 & \cdots & 0 \\
        0 & A_{c2} & \cdots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        0 & 0 & \cdots & A_{cm}
    \end{pmatrix}
    , \quad B_{c} = T^{-1}B
    = \begin{pmatrix}
        B_{c1} & 0 & \cdots & 0 \\
        0 & B_{c2} & \cdots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        0 & 0 & \cdots & B_{cm}
\end{pmatrix}
\end{equation}
Con \(A_{ci} \in \mathbb{R}^{n_{i} \times n_{i}}\)
e \(B_{ci} \in \mathbb{R}^{n_{i} \times 1}\) che valgono:
\[
A_{ci} =
\begin{pmatrix}
    0 & 1 & 0 & \cdots & 0 \\
    0 & 0 & 1 & \cdots & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    -a_{i1} & -a_{i2} & -a_{i3} & \cdots & -a_{in_i} \\
\end{pmatrix}
, \quad
B_{ci} =
\begin{pmatrix}
    0 \\
    0 \\
    \vdots \\
    0 \\
    1
\end{pmatrix}
\]
Inoltre si ha che \(n_{1} + n_{2} + \dots + n_{m} = n\). 
Notiamo che ogni coppia \((A_{ci}, B_{ci})\) rappresenta una 
forma canonica di controllabilità rispetto all'ingresso \(u_{i}\).
Notiamo 
che per come è scritta la matrice \(A_{c}\) con una retroazione 
di stato del tipo:
\[u = K_{c}z\]
con \(K_{c} \in \mathbb{R}^{m \times n}\):
\[
K_{c} =
\begin{pmatrix}
    k_{c1} & 0 & \cdots & 0 \\
    0 & k_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & k_{cm}
\end{pmatrix}
\]
con \(k_{ci} \in \mathbb{R}^{1 \times n_{i}}\).
Con \(K_{c}\) scritto in questo modo 
si ha che la matrice della dinamica del sistema 
in retroazione di stato è:
\[
A_{c} + B_{c}K_{c} =
\begin{pmatrix}
    A_{c1} & 0 & \cdots & 0 \\
    0 & A_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & A_{cm}
\end{pmatrix}
+
 \begin{pmatrix}
        B_{c1} & 0 & \cdots & 0 \\
        0 & B_{c2} & \cdots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        0 & 0 & \cdots & B_{cm}
\end{pmatrix}
\begin{pmatrix}
    k_{c1} & 0 & \cdots & 0 \\
    0 & k_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & k_{cm}
\end{pmatrix}
\]
Notando che \(B_{ci} k_{ci} \in \mathbb{R}^{n_{i} \times n_{i}}\)
si ha che:
\[
A_{c} + B_{c}K_{c} =
\begin{pmatrix}
    A_{c1} + B_{c1}k_{c1} & 0 & \cdots & 0 \\
    0 & A_{c2} + B_{c2}k_{c2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & A_{cm} + B_{cm}k_{cm}
\end{pmatrix}
\]
Ma la matrice \(A_{c} + B_{c} + K_{c}\)
è diagonale a blocchi dunque si ha che
gli autovalori della matrice sono gli autovalori
dei blocchi diagonali:
\[
\sigma(A_{c} + B_{c}K_{c}) =
\bigcup_{i=1}^{m}
\sigma(A_{ci} + B_{ci}k_{ci})
\]
Ma ogni singolo blocco diagonale 
\(A_{ci} + B_{ci}k_{ci}\) rappresenta un sistema SISO
in forma canonica di controllabilità, e la coppia \((A_{ci}, B_{ci})\)
è completamente controllabile per ipotesi (essendo 
controllabile il sistema originale \((A,B)\)),
dunque per il teorema di assegnamento degli autovalori
applicato ai sistemi SISO esiste \(k_{ci}\)
tale che possiamo assegnare gli autovalori
di ogni blocco diagonale \(A_{ci} + B_{ci}k_{ci}\).
Questo \(k_{ci}\) si trova imponendo
che il polinomio caratteristico del blocco
\(A_{ci} + B_{ci}k_{ci}\)
sia uguale al polinomio caratteristico
desiderato:
\[\det(sI - (A_{ci} + B_{ci}k_{ci})) =
    s^{n_{i}} + \alpha_{i1}s^{n_{i}-1} +
     \alpha_{i2}s^{n_{i}-2} + \ldots + \alpha_{in_{i}}
\]
Ovviamente questo va fatto \(\forall i=1, \dots , m\).
Una volta trovati tutti i \(k_{ci}\)
possiamo costruire la matrice \(K_{c}\), 
per riportarla nella base originale del sistema
basta ricordare:
\[u=K_{c} z= K_{c} T^{-1}x \Longrightarrow 
K= K_{c}T^{-1}\]


\section{Metodo dell'equazione di Sylvester}
Un altro metodo per l'assegnamento degli autovalori 
per sistemi MIMO è il metodo dell'equazione di Sylvester.
L'equazione di Sylvester è la seguente equazione matriciale:
\begin{equation}
    AX + XB = C
\end{equation}
in cui \(A \in \mathbb{R}^{n \times n}\),
\(B \in \mathbb{R}^{m \times m}\) e \(C \in \mathbb{R}^{n \times m}\)
sono matrici note, mentre \(X \in \mathbb{R}^{n \times m}\)
è la matrice incognita da trovare. Andiamo ad analizzare 
questa equazione:
\begin{itemize}
    \item \textbf{Unicità della soluzione}: L'equazione di Sylvester ammette
    una soluzione unica se e solo se gli spettri (cioè 
    gli insiemi degli autovalori) delle matrici \(A\) e \(-B\)
    sono disgiunti, cioè hanno intersezione uguale all'insieme vuoto:
    \[\sigma(A) \cap \sigma(-B) = \emptyset \Longleftrightarrow 
    \lambda_{i}(A) + \lambda_{j}(B) \neq 0 \quad \forall i,j\]
    in parole povere le matrici \(A\) e \(B\) non devono avere autovalori
    con segni opposti, cioè \(A\) e \(-B\) non devono avere autovalori in comune.
    Ad esempio se \(A\) ha un autovalore \(\lambda_{A} = 2\) e \(B\) ha un autovalore 
    \(\lambda_{B} = -2\) allora l'equazione di Sylvester non ammette una soluzione unica.
    \item \textbf{Esistenza della soluzione}: L'equazione di Sylvester ammette almeno
    una soluzione se e solo se:
    \[vec(C) \in Im \left(I_{m} \otimes A + B^{T} \otimes I_{n}\right)\]
    cioè se la matrice \(C\) appartiene all'immagine dell'operatore \(L(X)\):
    \[L(X) = AX + XB\]
    cioè esiste una matrice \(X \in \mathbb{R}^{n \times m}\) tale che \(L(X) = C\).
\end{itemize}

Ora torniamo al nostro problema di assegnamento degli autovalori
per sistemi MIMO. Ricordiamo che il nostro obiettivo è trovare 
la matrice \(K\) tale che:
\[\sigma(A + BK) =
\left\{\lambda_{1}, \lambda_{2}, \ldots, \lambda_{n}\right\}\]
Ma se esiste questa \(K\) allora costruita una matrice \(T\)
che ha sulle colonne gli autovettori associati agli autovalori
desiderati si ha che per 
la definizione di autovettore e autovalore (poichè
il prodotto \((A+BK)T\) equivale a moltiplicare la matrice
\(A+BK\) per ogni autovettore sulle colonne di \(T\)):
\[(A + BK)T = T \Lambda \]
con \(\Lambda\) matrice diagonale(o a blocchi) con gli autovalori desiderati sulla diagonale.
Andando a sviluppare i calcoli si hanno
\[AT + BKT = T \Lambda \]
Portando il termine \(T \Lambda\) a sinistra e \(BKT\) a destra si ha:
\[AT - T \Lambda = - BKT \]
In cui ponendo \(F=-KT\) si ha:
\[AT - T \Lambda = B F \]
Questa è un'equazione di Sylvester
(a meno del segno del secondo termine a primo membro) in cui \(X=T\).
Dunque se riusciamo a risolvere l'equazione di Sylvester
troviamo una \(X\) che ci permette di ricavare una matrice \(K\)
tale che la matrice \(A+BK\) abbia gli autovalori desiderati,
la matrice \(K\) si ricava come:
\[F=-KT=-KX \Longrightarrow K=-F X^{-1} = -F T^{-1}\]


Nella pratica per assegnare gli autovlari tramite l'equazione di Sylvester
si seguono i seguenti passi:
\begin{enumerate}
    \item Si scelgono gli autovalori desiderati
    \(\left\{\lambda_{1}, \lambda_{2}, \ldots, \lambda_{n}\right\}\)
    e si costruisce la matrice \(\Lambda\) con questi autovalori
    sulla diagonale (o a blocchi).
    \item Si costruisce una matrice \(F \in \mathbb{R}^{m \times n}\)
    a piacere (ad esempio con elementi casuali).
    \item Si risolve l'equazione di Sylvester:
    \[AX - X \Lambda = B F \]
    la soluzione \(X\) trovata è proprio la matrice \(T\) degli autovettori
    associati agli autovalori desiderati.
    \item Si calcola la matrice \(K\) come:
    \[K = - F X^{-1} = - F T^{-1}\]
\end{enumerate}
Ovviamente al variare della matrice \(F\) si ottengono
differenti matrici \(K\) che risolvono il problema, dunque 
è sulla matrice \(F\) che possiamo agire per ottenere
differenti soluzioni del problema di assegnamento degli autovalori.
Andiamo ora a definire il condizionamento di una matrice.
    A noi interessa anche che la matrice \(K\) non vari troppo al variare
delle matrici \(A\), \(B\) e \(\Lambda\), dunque ci interessa
che trovare un parametro per valutare la sensibilità numerica della matrice \(K\)
al variare delle matrici \(A\), \(B\) e \(\Lambda\). Ovviamente la 
sensibilità numerica di \(K\) dipende dalla sensibilità numerica
della matrice \(X\).

\begin{definizione}
Questo parametro prende il nome di condizionamento di una matrice ed è definito come:
\begin{equation}
    cond(X) = \|X\| \|X^{-1}\|
\end{equation}
Maggiore è il condizionamento di una matrice,
maggiore è la sensibilità numerica della matrice, dunque il nostro 
obiettivo è trovare una matrice \(X\) con condizionamento il più basso possibile.
\end{definizione}


Andiamo ora trasformare la condizione di esistenza della soluzione
dell'equazione di Sylvester in una condizione sulla coppia \((A,B)\).
Nello specifico la soluzione dell'equazione di Sylvester esiste ed è unica se e solo se
la coppia \((A,B)\) è completamente raggiungibile.
Infatti, se la coppia \((A,B)\) non è completamente raggiungibile,
il sistema può essere portato nella forma di Kalman 
di controllabilità, in cui \(\bar{A}\) e 
\(\bar{B}\) valgono:
\[
\bar{A} =
\begin{pmatrix}
    A_{C} & A_{12} \\
    0 & A_{NC}
\end{pmatrix}
, \quad
\bar{B} =
\begin{pmatrix}
    B_{C} \\
    0
\end{pmatrix}
\]
dove:
\begin{itemize}
    \item La coppia \((A_{C}, B_{C})\) è completamente controllabile
    \item \(A_{NC}\) rappresenta la parte non raggiungibile del sistema.
\end{itemize}
Quindi se andiamo a scrivere l'equazione di Sylvester
per \(\bar{A}\) e \(\bar{B}\) si ha:
\[\bar{A}X - X \Lambda = \bar{B} F \]
Dove le equazioni nelle righe di \(\bar{A}\) e \(\bar{B}\)
in cui il sistema non è controllabile si riducono a:
\[A_{NC} X_{NC} - X_{NC} \Lambda = 0 \]
Ma l'ultima equazione è soddisfatta solo se gli autovalori 
di \(A_{NC}\) e \(\Lambda\) sono uguali, cioè 
se non cambiamo gli autovalori della parte non controllabile del sistema.
Facciamo ora una considerazione sulla scelta degli autovalori.
Se siamo obbligati a scegliere autovalori di \(\Lambda\)
uguali ad autovalori di \(A\),per soddisfare delle specifiche di progetto,
 allora l'equazione di Sylvester non ammette più \textbf{soluzione unica},
e i casi possibili sono due:
\begin{itemize}
    \item L'equazione di Sylvester non ammette soluzioni (il sistema non è raggiungibile)
    \item L'equazione di Sylvester ammette infinite soluzioni (il sistema è raggiungibile)
\end{itemize}
Nel primo caso abbiamo che non esiste una \(X\) che risolve l'equazione
di Sylvester, dunque non possiamo seguire questa strada per trovare \(K\).
Nel secondo caso invece esistono infinite matrici \(X\), dunque infinite
matrici \(K\) che risolvono il problema di assegnamento degli autovalori.
Per garantire un condizionamento migliore del problema invece di scegliere 
autovalori di \(\Lambda\) uguali ad autovalori di \(A\) 
è meglio scegliere autovalori di \(\Lambda\) vicini, ma non proprio uguali 
agli autovalori di \(A\).

\section{Metodo di Kautsky-Nichols-Van Dooren}
Il metodo di Kautsky-Nichols-Van Dooren è un metodo iterativo 
per ottenere una matrice \(K\) ,che risolve il problema di assegnamento
degli autovalori per sistemi MIMO, con un buon condizionamento. Ma il condizionamento
di \(K\) ricordiamo dipendere dal condizionamento della matrice \(X\)
(matrice di autovettori)
che risolve l'equazione di Sylvester. 
Il metodo di Kautsky-Nichols-Van Dooren consiste dei seguenti passaggi:
\begin{enumerate}
    \item Si scelgono gli autovalori desiderati
    \(\left\{\lambda_{1}, \lambda_{2}, \ldots, \lambda_{n}\right\}\)
    e si costruisce la matrice \(\Lambda\) con questi autovalori
    sulla diagonale (o a blocchi).
    \item Si scelgono i vettori \(f_{i}\) in modo casuale (uno per ogni autovalore)
    \item Per ogni \(i\) si risolve il sistema di equazioni:
    \[ \left(A - \lambda_{i} I\right)x_{i} = -Bf_{i}\]
    Ottendendo così per ogni \(i\) un vettore \(x_{i}\).
    \item Si costruisce la matrice \(X\) con i vettori \(x_{i}\) come colonne:
    \[ X = \begin{pmatrix}
        x_{1} & x_{2} & \ldots & x_{n}
    \end{pmatrix}\]
    \item Si valuta il condizionamento di \(X\):
    \[ cond(X) = \|X\| \|X^{-1}\|\]
    \item Se il condizionamento di \(X\) non è accettabile si 
    ritorna al passo 2 e si scelgono nuovi vettori \(f_{i}\).
    Mentre se il condizionamento è accettabile si procede con il passo successivo.
    \item Si calcola la matrice \(F\) come:
    \[ F = \begin{pmatrix}
        f_{1} & f_{2} & \ldots & f_{n}
    \end{pmatrix}\]
    \item Si calcola la matrice \(K\) come:
    \[ K = - F X^{-1} \]
\end{enumerate}

\section{Diagonalizzare}

Sia dato un sistema LTI descritto dalle equazioni di stato:
\[
\dot{x}(t) = Ax(t) + Bu(t)
\]
quando noi diamo un sistema in questa forma diamo per assodato che il vettore 
\(x\) sia scritto nella base canonica di \(\mathbb{R}^{n}\).
Se la matrice \(A\) è diagonalizzabile, ci poniamo il problema di portare \(x\)
in un nuovo stato \(\hat{x}\) in cui \(A\) è diagonale. 
Dunque cerchiamo una matrice di trasformazione \(T\) tale che:
\[ x = T \hat{x} \Longrightarrow
\hat{A} = T^{-1} A T \textnormal{ è diagonale}\] 
Ma come si può immediatamente notare la matrice \(T\) è la matrice del cambiamento 
di base dalla base canonica alla base che diagonalizza \(A\).
Quindi a noi basta trovare la matrice che permette di portare il vettore \(\hat{x}\),
scritto nella base che diagonalizza \(A\), 
nel vettore \(x\) scritto nella base canonica.
Ma la base che diagonalizza \(A\) è formata dagli autovettori di \(A\),
dunque scegliamo un insieme di autovettori linearmente indipendenti di \(A\):
\[ \hat{B} = \left\{v_{1}, v_{2}, \ldots, v_{n}\right\} \] 
Per calcolare \(T\) dobbiamo ricordare che la matrice del cambiamento di base
si calcola attraverso l'applicazione identità (che è un applicazione lineare),
dunque applichiamo l'identità agli autovettori scelti:
\[ id(\hat{B}) =\left\{v_{1} , v_{2} , \ldots , v_{n}\right\} \]
Ora scomponiamo i vettori rispetto alla base canonica 
ed incolonniamoli come colonne della matrice \(T\)(
la base canonica è molto comoda perchè ci permette di scrivere i vettori
proprio come sono), dunque la matrice \(T\) vale:
\[ T = \begin{pmatrix}
    v_{1} & v_{2} & \ldots & v_{n}
\end{pmatrix}\]
In cui i vettori \(v_{1}, v_{2}, \ldots , v_{n} \in \mathbb{R}^{n \times 1}\)
sono vettori colonna \(n \times 1\), dunque la matrice \(T \in \mathbb{R}^{n \times n}\).



